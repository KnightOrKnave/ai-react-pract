# チャプター2講座資料: 変数・型・所有権の直感

## 目的と持ち帰り
- 不変/可変変数束縛、シャドーイングの違いを言語化できる。
- `String`と`&str`のメモリ配置と所有権の動きを説明できる。
- `Copy`トレイトが付く型とムーブセマンティクスを区別できる。

## 講義アウトライン
1. 変数束縛
   - 不変がデフォルト、`let mut`は「再束縛ではなく可変借用を許す束縛」。
   - シャドーイングは新しい変数を作るため、型を変えられる。
2. スタックとヒープ
   - `String`はヒープに実データ、スタックにポインタ＋長さ＋容量。
   - `&str`はスライス参照（長さ・ポインタのみ）。
3. 所有権とムーブ
   - `Copy`トレイトが自動実装されるスカラー型はビットコピーで共有可。
   - `String`は`Copy`でないのでムーブで元変数は使えなくなる。
4. `clone`と借用
   - `clone`は深いコピー（ヒープを複製）なのでコストが高い。
   - 借用（`&T`）は所有権を移さずに読み取りだけを許す。

## デモコード（ライブ用）
```rust
fn main() {
    let x = 5;              // Copy
    let y = x;              // xもyも使える
    let s1 = String::from("hi");
    let s2 = s1;            // 所有権がムーブ
    // println!("{s1}");    // ここはコンパイルエラー
    let s3 = s2.clone();    // ヒープを複製
    println!("{s2}, {s3}");
}
```

## ハンズオン課題（講義中）
1. `String`と`&str`を受け取る関数を2つ作り、呼び出し元での利用可否を確認する。
2. `Copy`な型（`i32`, `bool`, `(i32, i32)`）と`Copy`でない型（`String`, `Vec<i32>`）でムーブ後に何が起きるかをコンパイルエラーで見る。
3. `drop`を明示的に呼ぶ例 (`std::mem::drop`) とスコープ終了による破棄の順序を`println!`で追跡する。

## 練習問題（宿題）
1. `fn takes_ownership(s: String)`と`fn borrows(s: &str)`を用意し、呼び出し前後の変数利用可否をコメントで表にまとめる。
2. `Copy`でない型を`clone`するケースと借用で済ませるケースを比較し、どちらを選ぶかの判断基準を箇条書きにする。
3. `String`を引数に取り、`usize`（長さ）と元の`String`をタプルで返す関数を実装し、ムーブと返却で所有権が戻ることを確認する。

## チェックリスト
- [ ] `let`と`let mut`の挙動を実演した
- [ ] シャドーイングで型を変える例を示した
- [ ] `Copy`とムーブの違いをコンパイルエラーで確認した
- [ ] `clone`と借用のトレードオフに触れた

## 補足資料
- Rust Book 4章「所有権」
- Rust By Example: `variable-bindings`, `scope-and-shadowing`, `ownership`
- サンプル: `samples/ch02_ownership_basics`
