# チャプター4講座資料: 所有権・借用・ライフタイムの基礎

## 目的と持ち帰り
- 不変借用と可変借用の同時性ルールを説明できる。
- スライス参照（`&[T]`, `&str`）で境界チェックが行われる理由を理解する。
- ライフタイム省略規則と明示注釈の雰囲気をつかむ。

## 講義アウトライン
1. 借用のルール
   - 不変借用は複数OK、可変借用は同時に1つだけ。
   - 可変借用が終わるタイミングはスコープ終端か最後の使用位置。
2. スライスと境界チェック
   - `&[T]`/`&str`は長さ情報を保持し、ランタイムで境界チェックが入る。
   - `split_at`や`get`で安全に部分参照を取る。
3. ライフタイム注釈
   - 省略規則：入力参照が1つなら出力参照は同じライフタイムに束縛される、など3パターン。
   - 明示注釈が必要な例：複数入力からどちらを返すかわからない場合。

## デモコード（ライブ用）
```rust
fn longest<'a>(a: &'a str, b: &'a str) -> &'a str {
    if a.len() >= b.len() { a } else { b }
}

fn main() {
    let mut title = String::from("Rust");
    let t1 = &title;
    let t2 = &title;
    println!("{t1} {t2}");
    let t3 = &mut title; // ここでt1/t2の借用はもう使われないと推論される
    t3.push_str(" Book");
    println!("{t3}");
    let s = String::from("hello world");
    println!("{}", longest(&s[..5], &s));
}
```

## ハンズオン課題（講義中）
1. 可変借用を2つ同時に行うコードをあえて書き、エラーメッセージを和訳する。
2. `fn first_char(s: &str) -> Option<char>`を実装し、借用を返すケースを体験する。
3. `fn max_in(slice: &[i32]) -> Option<i32>`を実装し、スライスで境界チェックされることを確認する。

## 練習問題（宿題）
1. `split_at`で2つの不変スライスを取り、合計長さを返す関数を書いてテストする。
2. 複数の可変参照が必要になるケースを`Vec::split_at_mut`で解決する例を作る。
3. `fn longest<'a>(a: &'a str, b: &'a str) -> &'a str`からライフタイム注釈を外し、エラー内容をコメントでまとめる。

## チェックリスト
- [ ] 不変/可変借用の同時性ルールを示した
- [ ] スライスでの安全性と境界チェックを説明した
- [ ] ライフタイム省略規則と明示注釈例を提示した
- [ ] 借用チェッカのエラーメッセージを確認した

## 補足資料
- Rust Book 4章「参照と借用」、10章「ライフタイム」
- Rust By Example: `scope/lifetime`
- サンプル: `samples/ch04_borrowing_lifetimes`
